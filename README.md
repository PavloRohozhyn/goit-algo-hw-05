### Завдання 1 ([task1.py](task1.py))
Додати метод delete для видалення пар ключ-значення таблиці HashTable , яка реалізована в конспекті.

### Завдання 2 ([task2.py](task2.py))
Реалізувати двійковий пошук для відсортованого масиву з дробовими числами. Написана функція для двійкового пошуку повинна повертати кортеж, де першим елементом є кількість ітерацій, потрібних для знаходження елемента. Другим елементом має бути "верхня межа" — це найменший елемент, який є більшим або рівним заданому значенню.

### Завдання 3 ([task3.py](task3.py))
Порівняти ефективність алгоритмів пошуку підрядка: Боєра-Мура, Кнута-Морріса-Пратта та Рабіна-Карпа на основі двох текстових файлів ([стаття 1](task3_article_one.txt)), ([стаття 2](task3_article_two.txt)). Використовуючи timeit, треба виміряти час виконання кожного алгоритму для двох видів підрядків: одного, що дійсно існує в тексті, та іншого — вигаданого (вибір підрядків за вашим бажанням). На основі отриманих даних визначити найшвидший алгоритм для кожного тексту окремо та в цілому.

![result](task3_result.png "result")

**Case** - Завдання яке виконується в тесті

**Knuth Morris Pratt** - час виконання алгоритму Кнута Морріса Пратта

**Boyer Moore** - час виконання алгоритму Боєра Мура

**Rabin Karp** - час  алгоритму Рабіна Карпа

Отже

**Knuth Morris Pratt** - Почесне друге місце.

**Boyer Moore** - Найшвидший алгоритм для кожного рядка в обох випадках, незалежно від того, чи підрядок існує.

**Rabin Karp** - Бронза, згідно тестів - найгірший результат.

тому, згідно результатів, використання **Boyer Moore** є найкращим вибором. 
